use.std::crypto::fri::ext2fri

#! Stores the layer commitments C followed by [d_size, t_depth, a1, a0] and [0, p, e1, e0] where:
#! 1) d_size is the domain size divided by 4 of the domain corresponding to C.
#! 2) t_depth is the tree depth of the Merkle tree with commitment C.
#! 3) (a0, a1) is the folding challenge to create the next layer.
#! 4) p is the query index and (e0, e1) is the evaluation at the first layer.
#! TODO: This processing function should in fact compute d_size and t_depth for each C
#! starting from the original domain size.
export.preprocess.4
    #adv_push.1
    locaddr.3                   
    adv_push.1                  #[num_layers, layer_ptr, g, ..]
    dup
    neq.0
    while.true
        push.0.0.0.0
        adv_loadw                       #[C, num_layers, ptr, ..]
        movup.5                         #[ptr, C, num_layers, ..]
        u32wrapping_add.1               #[ptr+1, C, num_layers, ..]
        dup movdn.5                     #[ptr+1, C, ptr+1, num_layers, ..]
        mem_storew                      #[C, ptr+1, num_layers, ..]
        adv_loadw                       #[d_size, t_depth, a1, a0, ptr+1, num_layers, ..]
        movup.4                         #[ptr+1, d_size, t_depth, a1, a0, num_layers, ..]
        u32wrapping_add.1               #[ptr+2, d_size, t_depth, a1, a0, num_layers, ..]
        dup movdn.6                     #[ptr+2, d_size, t_depth, a1, a0, num_layers, ptr+2, ..]
        mem_storew dropw                #[num_layers, ptr+2, ..]
        u32wrapping_sub.1 dup           #[num_layers-1, num_layers-1, ptr+2, ..]
        neq.0                           #[?, num_layers-1, ptr+2, ..]                          
    end

    #[ptr2n', rem_len, rem_ptr, g, ..]
    drop
    adv_push.1
    dup.1
    add.1
    swap.2          


    # value of the remainder codeword
    push.0.0.0.0
    push.1
    while.true
        adv_loadw
        movup.4
        add.1
        dup
        movdn.5
        mem_storew
        movup.5
        u32wrapping_sub.1
        movdn.5
        dup.5
        neq.0
    end

    # [ptr_(2n+rem_len/2)', rem_ptr, g]
    dropw
    swap 
    drop
    
    # number of queries
    adv_push.1

    # [ptr_(2n+rem_len/2)', num_q, query_start_ptr, rem_ptr, g]    
    dup.1               
    add.1
    swap.2

    # value of the queries and evaluations
    push.0.0.0.0
    push.1
    while.true
        adv_loadw
        movup.4
        add.1
        dup
        movdn.5
        mem_storew
        movup.5
        u32wrapping_sub.1
        movdn.5
        dup.5
        neq.0
    end

   
    # [ptr_queries_end, query_start_ptr, rem_ptr, g]    
    dropw
    swap 
    drop

    # [ptr_queries_end + 1, query_start_ptr, rem_ptr, g]
    add.1

    # [query_start_ptr, ptr_queries_end + 1, ptr_c_start, rem_ptr, g]  
    locaddr.3
    add.1
    swap.2
end

#! Checks that, for a query with index p at layer i, the folding procedure to create layer (i + 1)
#! was performed correctly. This also advances layer_ptr by 2 to point to the next query layer.
#!
#! Input:  [layer_ptr, layer_ptr, poe, p, e1, e0, layer_ptr, rem_ptr, x, x, x, x, x, x, x, x, ...]
#! Output: [layer_ptr + 2, layer_ptr + 2, poe^4, f_pos, ne1, ne0, layer_ptr + 2, rem_ptr, x, x, x, x, x, x, x, x, ...]
#! 
#! Cycles: 76
export.verify_query_layer.3
    
    # load layer commitment C as well as [a0, a1, t_depth, d_size] (7 cycles)
    swapdw
    movup.8
    add.1
    mem_loadw   # load [a0, a1, t_depth, d_size] from layer_ptr + 1
    swapw
    movup.8
    mem_loadw   # load C from layer_ptr
    # => [C, d_size, t_depth, a1, a0, poe, p, e1, e0, layer_ptr, rem_ptr, ...]

    # verify Merkle auth path for (index = f_pos, depth = t_depth, Root = C) (19 cycles)
    swapw.2             # [poe, p, e1, e0, d_size, t_depth, a1, a0, C, layer_ptr, rem_ptr, ...]
    swap                # [p, poe, e1, e0, d_size, t_depth, a1, a0, C, layer_ptr, rem_ptr, ...]
    movup.4             # [d_size, p, poe, e1, e0, t_depth, a1, a0, C, layer_ptr, rem_ptr, ...]
    u32unchecked_divmod # p and d_size must be u32 values
    movup.5
    movupw.2
    dup.5
    movup.5             # [t_depth, f_pos, C, f_pos, d_seg, poe, e1, e0, a1, a0, layer_ptr, rem_ptr, ...]
    mtree_get           # [V, C, f_pos, d_seg, poe, e1, e0, a1, a0, layer_ptr, rem_ptr, ...]
    swapw
    # => [V, C, f_pos, d_seg, poe, e1, e0, a1, a0, layer_ptr, rem_ptr, ...]
    # where f_pos = p % d_size and d_seg = p / 4

    # unhash V and save the pre-image in locaddr.0 and locaddr.1; we don't clear values of C
    # because adv_pipe overwrites the first 8 elements of the stack (15 cycles)
    locaddr.1
    movdn.4
    push.0.0.0.0
    swapw
    push.0.0.0.0
    adv_pipe
    # => [T2, T1, T0, ptr, V, f_pos, d_seg, poe, e1, e0, a1, a0, layer_ptr, rem_ptr, ..]

    # assert T1 == V (16 cycles)
    swapw.3                    
    drop                         
    movup.3
    assert_eq                   
    movup.2
    assert_eq
    assert_eq
    movup.9
    assert_eq 
    
    # load (v7, ..v0) from memory (8 cycles)
    loc_loadw.1
    swapw
    loc_loadw.2
    # => [v7, ..., v0, f_pos, d_seg, poe, e1, e0, a1, a0, layer_ptr, rem_ptr, ...]

    # fold by 4 (1 cycle)
    fri_ext2fold4
    # => [x, x, x, x, x, x, x, x, x, x, layer_ptr + 2, poe^4, f_pos, ne1, ne0, rem_ptr, ...]

    # prepare for next iteration (10 cycles)
    swapdw
    dup.2
    movdn.7
    drop
    drop
    dup
    dup.7
    dup.1
    neq
    # => [?, layer_ptr + 2, layer_ptr + 2, poe^4, f_pos, ne1, ne0, layer_ptr + 2, rem_ptr, x, x, x, x, x, x, x, x, ...]
end

#! Verifies one FRI query.
#!
#! Input:  [poe, p, e1, e0, layer_ptr, rem_ptr, ...]
#! Output: [x, x, x, x, x, x, x, x, x, x, ...]
#!
#! - poe is g^p.
#! - p is a query index at the first layer. 
#! - (e0, e1) is an extension field elements corresponding to the value of the first layer at index p.
#! - layer_ptr is the memory address of the layer data (Merkle tree root, alpha etc.) for the next
#!   layer.
#! - rem_ptr is the memory address of the remainder codeword.
#!
#! Cycles: 40 + num_layers * 76
export.verify_query

    # prepare stack to be in a form that leverages the fri_ext2fold4 instruction output stack state
    # (16 cycles)
    dup.5
    dup.5
    push.0.0.0.0
    push.0.0.0.0
    swapdw
    dup
    dup
    movup.3
    neq
    # => [?, layer_ptr, layer_ptr, poe, p, e1, e0, layer_ptr, rem_ptr, 0, 0, 0, 0, 0, 0, 0, 0, ...]

    # verify correctness of layer folding
    while.true
        exec.verify_query_layer
    end
    # => [rem_ptr, rem_ptr, poe^(2^n), f_pos, ne1, ne0, rem_ptr, rem_ptr, x, x, x, x, x, x, x, x, ...]

    # check that remainder[f_pos] == (ne0, ne1)

    # Since each memory address contains two extension field elements, we have to determine which
    # of the two elements we should compare against. (7 cycles)
    movup.3
    push.2
    u32unchecked_divmod     # f_pos must be a u32 value
    movdn.4
    dup.1
    dup.1
    add
    # => [rem_ptr + offset, x, x, x, x, ?, ne1, ne0, rem_ptr, rem_ptr, x, x, x, x, x, x, x, x, ..]
    
    mem_loadw
    # => [e1', e0', e1, e0, ?, ne1, ne0, rem_ptr, rem_ptr, x, x, x, x, x, x, x, x, ..]
    
    # compare (ne0, ne1) to the appropriate tuple from the remainder word (14 cycles)
    movup.2
    swap
    dup.4
    cdrop
    movdn.3
    movup.2
    cdrop
    swap.2
    assert_eq
    assert_eq
    # => [x, x, x, x, x, x, x, x, x, x, ...]
end

#! Verifies a FRI proof where the proof was generated over quadratic extension of the base field
#! and layer folding was performed using folding factor 4.
#!
#! Input:  [query_start_ptr, query_end_ptr, layer_ptr, rem_ptr, g, ...]
#! Output: [...]
#!
#! - query_start_ptr is a pointer to a list of tuples of the form (e0, e1, p, 0) where p is a
#!   query index at the first layer and (e0, e1) is an extension field elements corresponding to
#!   the value of the first layer at index p.
#! - query_end_ptr is a pointer to the first empty memory address after the last (e0, e1, p, 0)
#!   tuple.
#! - layer_ptr is a pointer to the first layer commitment denoted throughout the code by C.
#!   layer_ptr + 1 points to the first [alpha0, alpha1, t_depth, d_size] where d_size is the size
#!   of initial domain divided by 4, t_depth is the depth of the Merkle tree commitment to the
#!   first layer and (alpha0, alpha1) is the first challenge used in folding the first layer.
#! - rem_ptr is a pointer to the first tuple of two consecutive degree 2 extension field
#!   elements making up the remainder codeword. This codeword can be of length either 32 or 64.
#!
#! The memory referenced above is used contiguously, as follows:
#!
#!   [layer_ptr ... rem_ptr ... query_start_ptr ... query_end_ptr]
#!
#! This means for example that:
#! 1. rem_ptr - 1 points to the last (d_size, t_depth, alpha1, alpha0) tuple.
#! 2. The length of the remainder codeword is 2 * (rem_ptr - query_start_ptr).
#!
#! Cycles: for domains of size 2^n where:
#! - n is even: 12 + 6 + num_queries * (40 + num_layers * 76 + 69) + 2626
#! - n is odd:  12 + 6 + num_queries * (40 + num_layers * 76 + 69) + 1356
export.verify.1

    # store [query_start_ptr, query_end_ptr, layer_ptr, rem_ptr] to keep track of all queries
    # (3 cycles)
    locaddr.0
    mem_storew

    # compute size of remainder divided by 2 to be used in determining the appropriate remainder
    # verification procedure. (5 cycles)
    dup
    dup.4
    sub
    movdn.5
    # => [query_start_ptr, query_end_ptr, layer_ptr, rem_ptr, g, rem_len]
    
    # compute number of remaining queries to be verified and assert it is not 0
    # (4 cycles)
    swap
    dup.1
    neq
    # => [?, query_start_ptr, layer_ptr, rem_ptr, g, rem_len, ...]

    while.true
        # load [e0, e1, p, 0] from memory i.e. next query data (7 cycles)
        push.0.0.0.0
        movup.4
        mem_loadw
        drop
        # => [p, e1, e0, layer_ptr, rem_ptr, g, rem_len, ...]

        # compute poe = g^p (43 cycles)
        dup.5
        dup.1
        exp.u32
        # => [poe, p, e1, e0, layer_ptr, rem_ptr, rem_len, ...]

        # we now have everything to verify query p
        exec.verify_query

        # prepare for next iteration (17 cycles)
        # => [x, x, x, x, x, x, x, x, x, x, g, rem_len, ...]
        dropw drop drop
        locaddr.0
        mem_loadw   # load [query_start_ptr, query_end_ptr, layer_ptr, rem_ptr]
        add.1
        locaddr.0
        mem_storew  # store [query_start_ptr + 1, query_end_ptr, layer_ptr, rem_ptr]
        swap
        dup.1
        neq
        # => [?, query_start_ptr + 1, layer_ptr, rem_ptr, g, rem_len, ...]
    end

    # ----- Verify that remainder corresponds to a low degree polynomial --------------------------

    # check if remainder is of size 64 (6 cycles)
    # => [x, x, rem_ptr, g, rem_len, ...]
    drop drop movdn.2 drop
    push.32
    eq
    # => [?, rem_ptr, ...]

    if.true
        # cycles 2626
        exec.ext2fri::verify_remainder_64
    else
        # cycles 1356
        exec.ext2fri::verify_remainder_32
    end
end
